# 0053_maximum-subarray

## 动态规划

相对于leetcode官方solution所说的贪心, 其实有更"科学"的解释.

经典的动态规划.

`O(n)`, 因为求的是序列内某一个元素之和最大的连续子串, 这个子串必定是`[0, i], i = {0, ..., n-1}`的tail.

那么问题就转化为, 对于串`s`, 求某一个元素之和最大的tail的和.

我们可以得到, 对于子串`[0, i], i = {0, ..., n-1}`的元素之和最大的tail的和`f(i)`, `f(i) = max{ f(i-1)+s[i], s[i] }`.

- 因为必须是tail, 要么是之前的tail的和加上最后一个元素, 要么直接取最后一个元素.

记录下所有的`f(i)`, 再求它们最大值即可得到我们需要的解.

但因为只求的最大值, 在求`f(i)`时, 只需要记录之前的最大值`max = { f(0), ..., f(i-1) }`, 和最后求得的`f(i-1)`即可.

## 分治

题解的分治不是很直观, 大致思路是, 对于某一个串`s, [0, n)`, 我们可以得到问题的解必定是以下三个值中最大的那个:

- 左半边的解
- 右半边的解
- 包含中间的值在内的, 一个最大和的子串:
  - 这个子串的头在左半边, 可以用单次循环求得左半边**所有的**tail的和的最大值
  - 这个子串的尾在右半边, 可以用单次循环求得右半边**所有的**"head"(此处并不是指单个元素)的和的最大值
  - 两边最大值相加得到中间子串的解

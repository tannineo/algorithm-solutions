# 0560_subarray-sum-equals-k

直觉, 计算连续序列的和, 我们可以通过滑动窗口.

这样的话, 对于某一个长度的子序列, O(n)时间内能完成计算.

遍历所有长度, 则时间内复杂度为O(n^2).

## 更快的做法 利用map

某一个子序列的和, 必是两个prefix的和的差.

我们通过一次循环计算prefix的和`sum`:

1. 计算当前的和`sum-k`, 是否**之前**出现在map中, 出现的话, 结果加上其出现的次数.

2. 用map来保存`sum`之前出现的次数.

注意, map初始有`map[0] = 1`, 代表空prefix.
